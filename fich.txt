-da 
-globals-aa
-instcount ->depende la prueba no sabemos cuantos tipos de instrucciones
-intervals ¿¿?? -> intervals y regions estan conectados en la info que nos dan. Intervals nos da la info detallada de los intervalos/regions.
-loops ??¿¿ -> hay que parsear el numero de loops (cada vez que se encuentra la palabra loop aumentar el contador). Ademas sacaremos tambien la profundidad máxima, es decir en cada linea nos quedamos con el numero de la profundidad hasta encontrar el mayor.
-regions ?? -> same as intervals, pero este nos da el numero de intervalos/regions.
-print-callgraph-sccs: noooo







Flags a probar para conseguir output
memdep
-print-cfg-sccs: 
-scalar-evolution -> importante entenderlo


IMPORTANTE: hay que mirar cuantos tipos de instrucciones hay para poder generar el vector. Cada posición del vector tendrá siempre el mismo significado. Si un test no tiene un tipo de instruccion, se rellena con 0. Ademas, cada vez que probremos, hay que guardar en un fichero las instrucciones encontradas, para luego poder usarlo para ver si hay nuevas instrucciones, utilizando el match de la expresion regular.

PARA UNIFICAR, HAY QUE DESCARGARSE EL PYTHON 3.7 Y SACAR LAS EXPRESIONES REGULARES. PODEMOS UTILIZAR DISTINTAS EXPRESIONES REGULARES PARA QUITAR LO QUE NO NECESITEMOS.

PPAL:
for each .c 
  -obtener .bc
   for each transform in transformlist 
	-obtener .bc'
	-nos quedamos con las transf con mejor promedio de tiempo de ejecucion
-sacar abstracciones de los .bc  y .bc' para obtener las experiencias -> (abs .bc,trasf,abs .bc',reward). Dicha exp se escribe en un fichero teniendo las abstracciones un formato de 3 digitos por campo del vector. Habria que guardar en otro fichero estas abstracciones ya que serán los estados de la matriz que hagamos posteriormente.
